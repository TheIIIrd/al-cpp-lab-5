/*
Лабораторная работа 4. Использование объектов своих классов в
последовательных контейнерах библиотеки STL.

В приложении организовать контейнер объектов своего класса
(элементы контейнера - объекты класса, не указатели!!!).

Класс должен иметь необходимые конструкторы, конструктор копирования
и перемещения при необходимости (обосновать отсутствие или наличие
необходимости), перегруженные операции присваивания с копированием и
перемещением при необходимости (обосновать отсутствие или наличие
необходимости), перегруженную операцию вставки в поток <<.

Обеспечить копирование одного контейнера в другой с помощью алгоритма
std::copy. А также сортировку объектов в исходном контейнере,для
шаблона vector или deque при сортировке использовать алгоритм std::sort
с двумя параметрами: итератор на начало и итератор на конец контейнера.

Исходные данные прочитать из текстового файла input.txt. Вывести в
выходной файл output.txt исходный контейнер, контейнер после сортировки,
использовать при этом перегруженную операцию вставки в поток, также
вывести в выходной файл контейнер, в который скопирован исходный контейнер.

+ Объект - автомобиль
(поля: название модели, массив расходов топлива из 3-х элементов
(на трассе, в городе, смешанный), максимальная скорость, мощность)
+ Сортировка по смешанному расходу топлива
+ Исходный контейнер vector, копируем в deque
*/

#include "../vehicle/vehicle.hpp" // Подключение заголовочного файла с описанием класса Vehicle
#include <fstream>
#include <set>
#include <unordered_set>

template <class T> void CustomOutput(T &_TMP) {
  // Открытие файла для записи
  std::ofstream output("../stream/output.txt", std::ios::app);

  output << _TMP << std::endl;    // Запись объекта в файл
  std::cout << _TMP << std::endl; // Вывод объекта на консоль

  // Закрытие файла
  output.close();
}

namespace std {
template <> struct hash<Vehicle> {
  size_t operator()(const Vehicle &_V) const {
    return std::hash<std::string>()(_V.get_model());
  }
};

} // namespace std

int main() {
  std::ofstream clear("../stream/output.txt"); // Очистка файла вывода
  clear.close();                     // Закрытие файла

  std::ifstream input("../stream/input.txt"); // Открытие файла для чтения

  std::set<Vehicle> _TEST1; // Создание вектора объектов класса Vehicle
  std::unordered_set<Vehicle> _TEST2;

  for (size_t i = 0; i < 5; ++i) {
    Vehicle _TMP; // Создание временного объекта Vehicle
    input >> _TMP; // Чтение данных из файла и инициализация объекта
    _TEST1.insert(_TMP); // Добавление объекта в сет
    _TEST2.insert(_TMP); // Добавление объекта в сет
  }

  // Вывод заголовка списка перед сортировкой
  CustomOutput("[+] This is set: ");

  // Вывод каждого элемента из вектора
  for (const auto &_EL : _TEST1)
    CustomOutput(_EL);

  // Вывод заголовка для скопированного вектора
  CustomOutput("[+] This is unorset: ");

  // Вывод каждого элемента из скопированного списка
  for (const auto &_EL : _TEST2)
    CustomOutput(_EL);

  return 0;
}
